/*
 * tbx RISC OS toolbox library
 *
 * Copyright (C) 2010 Alan Buckley   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*
 * selection.h
 *
 *  Created on: 12 Mar 2010
 *      Author: alanb
 */

#ifndef SELECTION_H_
#define SELECTION_H_

#include <vector>
#include "../listener.h"

namespace tbx {
namespace view {

/**
 * Class with the details of a select, deselect or toggle operation
 */
class SelectionChangedEvent
{
public:
	/**
	 * Construct a selection changed event
	 *
	 * @param first index of first item in selection
	 * @param last index of last item in selection
	 * @param selected true if items are being selected, false if they are being deselected
	 * @param final true if last event generated in one action.
	 */
	SelectionChangedEvent(unsigned int first, unsigned int last, bool selected, bool final = true) :
		 _first(first), _last(last), _selected(selected), _final(final) {}
	/**
	 * Default constructor creates a selection of item 0.
	 */
	SelectionChangedEvent() : _first(0),_last(0), _selected(true), _final(true) {};

private:
	unsigned int _first;
	unsigned int _last;
	bool _selected;
	bool _final;

public:
	/**
	 * Returns the first selected/deselected item in the range
	 */
	unsigned int first() const {return _first;}

	/**
	 * Set first selected
	 */
	void first(unsigned int value) {_first = value;}

	/**
	 * Returns the last selected/deselected item in the range
	 */
	unsigned int last() const {return _last;}

	/**
	 * Set last selected
	 */
	void last(unsigned int value) {_last = value;}

	/**
	 * Returns the type of the event
	 *
	 * @return
	 *    true if items in range were selected
	 *    false if items in range were deselected
	 */
	bool selected() const {return _selected;}

	/**
	 * Set selected flag
	 */
	void selected(bool value) {_selected = value;}


	/**
	 * Returns true if this is the last event in a
	 * group of events triggered by a single action.
	 *
	 * In a single selection model you would get
	 * an event with selected = false, final = false
	 * if there was an existing selection, before an
	 * event with selected = true, final = true
	 *
	 * In a multiple selection model you get final = false
	 * for all the events generated by a method that changes
	 * the selection except the last which has final = true
	 */
	bool final() const {return _final;}

	/**
	 * Set final flag
	 */
	 void final(bool value) {_final = value;}

};

/**
 * Listener for selection changed events
 */
class SelectionListener : public Listener
{
public:
	SelectionListener() {}
	virtual ~SelectionListener() {}

	/**
	 * Called whenever the selection has been changed
	 */
	virtual void selection_changed(const SelectionChangedEvent &event) = 0;
};

/**
 * Base class for selections of one or more indices from a zero based
 * range.
 */
class Selection
{
private:
	std::vector<SelectionListener *> _listeners;

protected:
	/**
	 * Protected constructor, must always use a subclass
	 */
	Selection() {}

	void fire_event(const SelectionChangedEvent &event);
	void fire_event(unsigned int index, bool selected, bool final);
	void fire_event(unsigned int from, unsigned int to, bool selected, bool final);

public:
	virtual ~Selection() {}

	/**
	 * Add listeners
	 */
	void add_listener(SelectionListener *listener);
	void remove_listener(SelectionListener *listener);

	/**
	 * Type of selection
	 */
	enum Type {NONE, SINGLE, MULTIPLE};

	/**
	 * Constant for indices when there is no selection
	 */
	static const unsigned int NO_SELECTION = -1;

	/**
	 * Override to return the type of this selection class
	 */
	virtual Type type() const = 0;

	/**
	 * Override to return true if an item is selected
	 *
	 * @param index of item to text
	 */
	virtual bool selected(unsigned int index) const = 0;

	/**
	 * Override to return first selected item.
	 *
	 * Note not all items between the first and last are necessarily
	 * selected.
	 */
	virtual unsigned int first() const = 0;
	/**
	 * Override to return last selected item
	 */
	virtual unsigned int last() const = 0;

	/**
	 * Override to return true if selection is empty
	 */
	virtual bool empty() const = 0;

	/**
	 * Override to return the number of selected items.
	 *
	 * Note: If the exact number is not needed it is usually
	 * quicker to use empty(), any(), one() or many(),
	 */
	virtual unsigned int count() const = 0;

	/**
	 * Override to return true if one or more items are selected
	 */
	virtual bool any() const = 0;

	/**
	 * Override to return true if only one item is selected
	 */
	virtual bool one() const = 0;

	/**
	 * Override to return true if more than one item is selected
	 */
	virtual bool many() const = 0;

	/**
	 * Override called by the object selection is on when new items have
	 * been inserted and selected items need to be moved
	 *
	 * @param index of the insertion
	 * @param count of items inserted
	 */
	 virtual void inserted(unsigned int index, unsigned int count) = 0;

	/**
	 * Override called by the object selection is on when items have
	 * been removed and selected items to be deleted or moved
	 *
	 * @param index of the insertion
	 * @param count of items inserted
	 */
	 virtual void removed(unsigned int index, unsigned int count) = 0;

	/**
	 * Override to clear the current selection.
	 */
	virtual void clear() = 0;

	/**
	 * Override to change selection to given item.
	 *
	 * This will automatically deselect any existing selection
	 *
	 * @param index to select
	 */
	virtual void set(unsigned int index) = 0;

	/**
	 * Override to select an item
	 *
	 * @param index to select
	 */
	virtual void select(unsigned int index) = 0;

	/**
	 * Override to clear the selection for an item
	 *
	 * @param index to deselect
	 */
	virtual void deselect(unsigned int index) = 0;

	/**
	 * Override to toggle the selection for an item
	 *
	 * @param index to toggle
	 */
	virtual void toggle(unsigned int index) = 0;

	/**
	 * Override to change selection to given item.
	 *
	 * This will automatically deselect any existing selection
	 * outside the range
	 *
	 * @param from first index to select
	 * @param to last index to select
	 */
	virtual void set(unsigned int from, unsigned int to) = 0;

	/**
	 * Override to selection a range of items
	 *
	 * @param from first index to select
	 * @param to last index to select
	 */
	virtual void select(unsigned int from, unsigned int to) = 0;

	/**
	 * Override to deselect a range of items
	 *
	 * @param from first index to deselect
	 * @param to last index to deselect
	 */
	virtual void deselect(unsigned int from, unsigned int to) = 0;

	/**
	 * Override to toggle the selection of a range of items
	 *
	 * @param from first index to toggle
	 * @param to last index to toggle
	 */
	virtual void toggle(unsigned int from, unsigned int to) = 0;

protected:
	/**
	 * Class derived from in subclasses to actually provided
	 * the iterator implementation
	 */
	class IteratorImpl
	{
		unsigned int _refcount;
	public:
		/**
		 * Construct iterator implementation
		 */
		IteratorImpl() : _refcount(1) {}
		/**
		 * Destructor does nothing
		 */
		virtual ~IteratorImpl() {}
		/**
		 * Increase reference count
		 */
		void add_ref() {++_refcount;}
		/**
		 * Decrease reference count and delete this if reference count
		 * becomes zero.
		 */
		void release() {if (--_refcount == 0) delete this;}
		/**
		 * Check if the iterator implementation is being shared between
		 * two or more iterators
		 *
		 * @returns true if this is shared
		 */
		bool shared() const {return _refcount > 1;}

		/**
		 * Override this method to return a copy of
		 * the iterator implementation.
		 *
		 * @returns copy of iterator implementation
		 */
		virtual IteratorImpl *clone() = 0;
		/**
		 * Override this to get the current index.
		 *
		 * @return current index or NO_INDEX if at the end
		 */
		virtual unsigned int index() const = 0;
		/**
		 * Override this method to advance the iterator to the next
		 * item.
		 */
		virtual void next() = 0;
	};
	/**
	 * Override to return the iterator implementation for
	 * the selection iterator to used.
	 *
	 * @return Iterator implementation for this selection type.
	 */
	virtual IteratorImpl *get_iterator_impl() const = 0;

public:
	/**
	 * Class to iterate through all the selected indices
	 */
	class Iterator
	{
		IteratorImpl *_impl;
		friend class Selection;
		Iterator()  {_impl = 0;}
		Iterator(IteratorImpl *impl) : _impl(impl) {};

	public:
		Iterator(const Iterator &other);
		~Iterator();
		Iterator &operator=(const Iterator &other);
		bool operator==(const Iterator &other) const;
		bool operator!=(const Iterator &other) const;
		unsigned int operator*() const;

		Iterator &operator++();
		Iterator operator++(int);
	};

	Iterator begin() const;
	Iterator end() const;

};

/**
 * Class to represent a single selection
 */
class SingleSelection : public Selection
{
private:
	unsigned int _selected;

public:
	SingleSelection() {_selected = NO_SELECTION;}

	/**
	 * Returns the type of this selection class
	 */
	virtual Type type() const {return SINGLE;}

	/**
	 * Returns true if an item is selected
	 *
	 * @param index of item to test
	 */
	virtual bool selected(unsigned int index) const {return _selected == index;}

	/**
	 * Returns first selected item.
	 *
	 * Only one item is ever selected so first() always equals last().
	 */
	virtual unsigned int first() const {return _selected;}
	/**
	 * Returns last selected item
	 */
	virtual unsigned int last() const {return _selected;}

	/**
	 * Returns true if selection is empty
	 */
	virtual bool empty() const {return (_selected == NO_SELECTION);}

	/**
	 * Return the number of selected items.
	 */
	virtual unsigned int count() const {return (_selected == NO_SELECTION) ? 0 : 1;}

	/**
	 * Returns true if one or more items are selected
	 */
	virtual bool any() const {return (_selected != NO_SELECTION);}

	/**
	 * Returns true if only one item is selected
	 */
	virtual bool one() const {return (_selected != NO_SELECTION);};

	/**
	 * Always returns false. This class has a maximum of one selection
	 */
	virtual bool many() const {return false;}

	// Methods called by owner of this selection
	virtual void inserted(unsigned int index, unsigned int count);
	virtual void removed(unsigned int index, unsigned int count);

	// Methods called to manipulate the selection
	virtual void clear();
	virtual void set(unsigned int index);
	virtual void select(unsigned int index);
	virtual void deselect(unsigned int index);
	virtual void toggle(unsigned int index);
	virtual void set(unsigned int from, unsigned int to);
	virtual void select(unsigned int from, unsigned int to);
	virtual void deselect(unsigned int from, unsigned int to);
	virtual void toggle(unsigned int from, unsigned int to);

protected:
	/**
	 * Class derived to implement iterator
	 */
	class SingleIteratorImpl : public IteratorImpl
	{
		unsigned int _index;
	public:
		/**
		 * Construct iterator for item with given index
		 *
		 * @param index index of selected item
		 */
		SingleIteratorImpl(unsigned int index) : _index(index) {}
		/**
		 * Get copy of this iterator implentation
		 *
		 * @returns copy of this with reference count increased
		 */
		virtual IteratorImpl *clone() {add_ref(); return this;}
		/**
		 * Get the current index
		 *
		 * @return current index or NO_SELECTION if at end of selection
		 */
		virtual unsigned int index() const {return _index;}
		/**
		 * Advance iterator
		 *
		 * For the single selection model this makes the index NO_SELECTION.
		 */
		virtual void next() {_index = NO_SELECTION;}
	};
	virtual IteratorImpl *get_iterator_impl() const {return new SingleIteratorImpl(_selected);}

};

/**
 * Class to implement multiple selections
 */
class MultiSelection : public Selection
{
	typedef std::pair<unsigned int, unsigned int> Range;
	unsigned int _first;
	unsigned int _last;
	std::vector<Range> _selected;
	typedef std::vector<Range>::iterator RangeIterator;
	typedef std::vector<Range>::const_iterator ConstRangeIterator;
public:
	MultiSelection() : _first(NO_SELECTION), _last(NO_SELECTION) {}
	virtual ~MultiSelection() {}

	/**
	 * Returns the type of this selection class
	 */
	virtual Type type() const {return MULTIPLE;}

	/**
	 * Returns true if an item is selected
	 *
	 * @param index of item to test
	 */
	virtual bool selected(unsigned int index) const;

	/**
	 * Returns first selected item.
	 *
	 * Only one item is ever selected so first() always equals last().
	 */
	virtual unsigned int first() const {return _first;}
	/**
	 * Returns last selected item
	 */
	virtual unsigned int last() const {return _last;}

	/**
	 * Returns true if selection is empty
	 */
	virtual bool empty() const {return (_first == NO_SELECTION);}

	/**
	 * Return the number of selected items.
	 */
	virtual unsigned int count() const;

	/**
	 * Returns true if one or more items are selected
	 */
	virtual bool any() const {return (_first != NO_SELECTION);}

	/**
	 * Returns true if only one item is selected
	 */
	virtual bool one() const {return (_first != NO_SELECTION && _first == _last);};

	/**
	 * Returns true if there are more than one item selected
	 */
	virtual bool many() const {return (_first != NO_SELECTION) && (_first < _last);}

	// Methods called by owner of this selection
	virtual void inserted(unsigned int index, unsigned int count);
	virtual void removed(unsigned int index, unsigned int count);

	// Methods called to manipulate the selection
	virtual void clear();
	virtual void set(unsigned int index);
	virtual void select(unsigned int index);
	virtual void deselect(unsigned int index);
	virtual void toggle(unsigned int index);
	virtual void set(unsigned int from, unsigned int to);
	virtual void select(unsigned int from, unsigned int to);
	virtual void deselect(unsigned int from, unsigned int to);
	virtual void toggle(unsigned int from, unsigned int to);

protected:
	/**
	 * Class derived to implement iterator
	 */
	class MultiIteratorImpl : public IteratorImpl
	{
		ConstRangeIterator _current;
		ConstRangeIterator _end;
		unsigned int _index;

	public:
		MultiIteratorImpl(ConstRangeIterator start, ConstRangeIterator end);
		// Return a copy of the implementation
		virtual IteratorImpl *clone();
		// return the current index or NO_SELECTION if at end
		virtual unsigned int index() const {return _index;}
		// advance iterator
		virtual void next();
	};
	virtual IteratorImpl *get_iterator_impl() const;

private:
	// Helper functions
	RangeIterator find_last_ge(unsigned int index);
	void fire_changes(std::vector<SelectionChangedEvent> &changes);

};

}
}

#endif /* SELECTION_H_ */
