<chapter>
<title>The TBX event system</title>
<para>
 The TBX event system allows you to handle the events generated by the toolbox and the RISC OS WIMP.
 For most events you add and remove listeners for the particular event on the C++ object that
 you wish to detect the event for. This means that you can associate multiple actions to be
 run when an event occurs. When an event occurs a method in the listener is called and (in most cases)
 an object containing information on the event is passed in the call. Although most events
 are passed on to all their listeners, there are a few where a parameter in the passed event
 information can be set to stop this.
</para>
<para>
 The information for the event listeners is help separately
 from any C++ object/gadget/menu item class instance that
 has been created and is not affected by these being deleted
 or going out of scope. All event listeners are automatically
 removed when the underlying toolbox object that the events
 are on is destroyed.
</para>
<para>
 All event listening routines are given a pointer to the C++
 class instance that handles the event, so it is important
 that the handler class is not deleted before the event has
 been removed.
</para>

  <section>
    <title>Object/Gadget default events</title>
    <para>
      These are the default events generated by the underlying toolbox
      object/gadget.
    </para>
    <para>
      They are caught in a tbx application by adding a listener for the
      specific event to the object/gadget they apply to.
      <example>
        <title>To add a changed listener to a writeable field w</title>
        <programlisting>
          w.add_text_changed_listener(&amp;my_listener);
        </programlisting>
      The my_listener object is derived from a TextChangedListener and
      has its text_changed member called when the writeable field text
      changes.
      </example>
    </para>
    <para>
      You can add multiple listeners to the same event.
    </para>
    <note>
      <para>
        Note: The object/gadget must be set to deliver the event in
        the toolbox resource file for the listener to be called.
      </para>
    </note>
  </section>

 <section><title>User Events</title>
 <para>
These are events with number you have specified. They should be
 in the range 1 to 0x4FFF.
</para>
<para>
 These events are routed, that the item that is run is first
  tried on the object where the event originated.
  Then on the parent object. Next on the ancestor
  object and finally on the application.
</para>
<para>
 The first object/gadget that handles the event stops it
 from being bubbled up to the next higher level.
</para>
<para>
User events are caught in tbx by using the <function>add_command</function> method
on an object or the application.
</para>
</section>
  <section>
    <title>Commands</title>
    <para>
      The Command class is used as a base for commands that can
      be executed from an event. It includes a virtual execute
      method that needs to be overridden to provide the command
      functionality.
    </para>
    <para>
      Commands can be added to user events (see above) or to
      specific functionality of a gadget or object.

    </para>
  </section>
  <section>
    <title>WIMP window events</title>
    <para>
      A Toolbox application can also receive the lower level WIMP window
      events. These are things like key presses, mouse clicks and redraw
      events. In some cases the Toolbox intercepts these values or a
      flag in the Window object tells the WIMP it is not interested in
      them. In most cases there is a flag you can set on the Window to
      allow them to get through.
    </para>
    <para>
      These events are handled in code in exactly the same way as Toolbox
      events. i.e. There are <methodname>add_..._listener</methodname> and
      <methodname>remove_..._listener</methodname> methods on the
      <classname>tbx::Window</classname> class to add and remove the event
      handlers.
    </para>
  </section>
  <section>
    <title>WIMP application messages</title>
    <para>
      The RISC OS desktop also sends message to an application using
      WIMP messages. Some of these messages can also be sent from
      one application to another.
    </para>
    <para>
      There are three types of messages, user, recorded and acknowledged and
      TBX provides listeners on the <classname>tbx::Application</classname> class
      to handle them.
    </para>
    <para>
      A class <classname>tbx::WimpMessage</classname> exists to help interrogate
      the data received from these methods. It can also be used to send replies
      to a received message or to send your own messages to another application.
    </para>
    <para>
      TBX also provides some built in functionality to deal with some
      of the more common messages at a higher level. Like all such
      functionality you can ignore it and create your own using just
      the standard message listeners.
    </para>
    <para>
      A couple of the most useful are the PreQuit listener on the
      <classname>tbx::Application</classname> class and the handling of
      the data/file loading messages which can be routed to the
      iconbar icon/window or gadget the data/file was dropped
      on using the <methodname>add_loader</methodname> method provided
      on the relevant classes.
    </para>
  </section>
  <section>
    <title>Idle events and timers</title>
    <para>
      If you need to go some processing when the nothing else is
      happening in the WIMP you can add or remove a <classname>tbx:Command</classname>
      derived class to the <classname>tbx::Application</classname> class with
      the <methodname>add_idle_command</methodname> and <methodname>remove_idle_command</methodname>
      methods.
    </para>
    <para>
      You may also only wish to do this action after a set amount of time. In this case
      you add a <classname>tbx::Timer</classname> derived class to the
      <classname>tbx::Application</classname> class using the <methodname>add_timer</methodname>
      method giving it the interval between calls. To stop the timer call the <methodname>remove_timer</methodname>
      method on the <classname>tbx::Application</classname> class.
      Timers are only processed when there are no other events so they will not
      necessarily be delivered exactly on time.
    </para>
    <para>
      With both idle events and timers it is important that you remove them from
      the application when they are not required as it improves overall system
      performance.
    </para>
    <para>
      The TBX-Examples download contains an application called !StopWatch which
      demonstrates the use of a timer.
    </para>
  </section>
</chapter>
